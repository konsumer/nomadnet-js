<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <title>NomadnetJS</title>
    <style>
      .flex {
        display: flex;
      }
      .row {
        flex-direction: row;
        align-items: center;
        gap: 5px;
      }
      .nowrap {
        white-space: nowrap;
      }
      .mono {
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <main id="root" class="container">
      <h1><a href="https://github.com/konsumer/nomadnet-js" target="_new">NomadnetJS</a></h1>
      <p>This is a simple demo-client that communicates with Reticulum clients over a websocket. First, you will need a private-key. You can generate one or input one you got, previously.</p>
      <p>This does not persist anything (messages, your identity, etc) except peers it has seen. I may add that later, but for now, it's just a way to play around with reticulum.</p>

      <fieldset role="group">
        <input placeholder="PRIVATE KEY" id="inputPrivateKey" />
        <button id="buttonGenerate" class="secondary">GENERATE</button>
        <button id="buttonSet">SET</button>
      </fieldset>
      <fieldset role="group" class="flex row" hidden>
        <input type="text" id="lxmfAddress" readonly class="mono" />
        <button id="buttonAnnounce">ANNOUNCE</button>
      </fieldset>
      <div>
        <h3>Peers</h3>
        <ul id="peerList"></ul>
      </div>
      <toast-notification id="toast"></toast-notification>
    </main>
  </body>
</html>
<!-- this sets up the import-map that is needed for nomadnet-js -->
<script type="importmap">
  {
    "imports": {
      "@noble/ciphers/aes.js": "https://esm.sh/@noble/ciphers@0.5.3/aes.js",
      "@noble/curves/utils.js": "https://esm.sh/@noble/curves@2.0.1/es2022/utils.mjs",
      "@noble/ciphers/utils.js": "https://esm.sh/@noble/ciphers@0.5.3/webcrypto.js",
      "@noble/hashes/sha2.js": "https://esm.sh/@noble/hashes@1.4.0/sha2.js",
      "@noble/hashes/hmac.js": "https://esm.sh/@noble/hashes@1.4.0/hmac.js",
      "@noble/hashes/hkdf.js": "https://esm.sh/@noble/hashes@1.4.0/hkdf.js",
      "@noble/curves/ed25519.js": "https://esm.sh/@noble/curves@1.4.0/ed25519.js",
      "msgpackr": "https://esm.sh/msgpackr@1.10.1",
      "rns": "./src/index.js"
    }
  }
</script>
<script type="module">
  import * as rns from 'rns'
  import { bytesToHex, hexToBytes, randomBytes } from '@noble/curves/utils.js'

  const decoder = new TextDecoder()

  const WS_URL = 'wss://signal.konsumer.workers.dev/ws/reticulum'

  const packetTypeNames = {}
  packetTypeNames[rns.PACKET_DATA] = 'DATA'
  packetTypeNames[rns.PACKET_ANNOUNCE] = 'ANNOUNCE'
  packetTypeNames[rns.PACKET_LINKREQUEST] = 'LINKREQUEST'
  packetTypeNames[rns.PACKET_PROOF] = 'PROOF'

  // ANNOUNCE yourself
  function announce() {
    if (identity) {
      console.log(`ANNOUNCE (${identity.destinationHex})`)
      if (!ratchetPub) {
        addRatchet()
      }
      ws.send(rns.buildAnnounce(identity, identity.destinationHash, 'lxmf.delivery', ratchetPub))
    }
  }

  // add a new ratchet
  function addRatchet() {
    const ratchet = rns.ratchetCreateNew()
    ratchetPub = rns.ratchetGetPublic(ratchet)
    ratchets.push(ratchet)
  }

  // handle an incoming packet
  function handlePacket(data) {
    const packet = rns.decodePacket(new Uint8Array(data))
    const destinationHex = bytesToHex(packet.destinationHash)
    console.log(`${packetTypeNames[packet.packetType] || 'UNKNOWN'} (${destinationHex})`)

    if (packet.packetType === rns.PACKET_ANNOUNCE) {
      const announce = rns.announceParse(packet)
      console.log(`  Valid: ${announce.valid ? 'Yes' : 'No'}`)
      if (announce.valid) {
        peers[destinationHex] = { ...packet, ...announce, destinationHex }
        updatePeers()
      }
    }

    if (packet.packetType === rns.PACKET_DATA) {
      if (destinationHex === identity.destinationHex) {
        const messageId = rns.getMessageId(packet)
        console.log(`sending PROOF (${bytesToHex(messageId)})`)
        ws.send(rns.buildProof(identity, packet, messageId))
        const message = rns.parseLxmfMessage(rns.messageDecrypt(packet, identity, ratchets))
        message.sourceHex = bytesToHex(message.sourceHash)
        const title = decoder.decode(message.title)
        const content = decoder.decode(message.content)

        if (title.trim() === '') {
          toast.show(`<strong>${message.sourceHex}</strong><br/>${content}`)
        } else {
          toast.show(`<strong>${message.sourceHex}</strong><br/><strong>${title}</strong><br/>${content}`)
        }

        console.log({ ...message, title, content, timestamp: new Date(message.timestamp * 1000) })
      }
    }

    if (packet.packetType === rns.PACKET_PROOF) {
    }
  }

  const ws = new WebSocket(WS_URL)
  ws.binaryType = 'arraybuffer'
  ws.onmessage = (event) => handlePacket(event.data)
  ws.onerror = console.error

  let identity
  const messages = {}
  const ratchets = []
  let ratchetPub
  const peers = JSON.parse(localStorage.peers || '{}')
  updatePeers()

  function updatePeers() {
    localStorage.peers = JSON.stringify(peers)
    peerList.innerHTML = ''
    Object.values(peers).forEach((announce) => {
      const li = document.createElement('li')
      li.className = 'mono'
      li.textContent = announce.destinationHex
      peerList.appendChild(li)
    })
  }

  buttonGenerate.addEventListener('click', (e) => {
    inputPrivateKey.value = bytesToHex(randomBytes(64))
  })

  buttonAnnounce.addEventListener('click', announce)

  buttonSet.addEventListener('click', (e) => {
    if (inputPrivateKey.value?.length !== 128 || /[^0-9a-fA-F]/.test(inputPrivateKey.value)) {
      alert('Please enter or generate a valid private-key.')
    } else {
      identity = rns.getIdentityFromBytes(hexToBytes(inputPrivateKey.value))
      identity.destinationHash = rns.getDestinationHash(identity, 'lxmf', 'delivery')
      identity.destinationHex = bytesToHex(identity.destinationHash)
      inputPrivateKey.remove()
      buttonSet.remove()
      buttonGenerate.remove()
      lxmfAddress.value = identity.destinationHex
      lxmfAddress.parentElement.removeAttribute('hidden')
      // setInterval(announce, 60000 * 60) // announce every hour
      announce()
    }
  })

  class ToastNotification extends HTMLElement {
    constructor() {
      super()
      this.attachShadow({ mode: 'open' })
      this.shadowRoot.innerHTML = `
      <style>
        .toast {
          position: fixed;
          bottom: 20px;
          right: 20px;
          background-color: #333;
          color: white;
          padding: 15px;
          border-radius: 5px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
          opacity: 0;
          transition: opacity 0.5s ease-in-out;
          z-index: 1000;
        }
        .toast.show {
          opacity: 1;
        }
      </style>
      <div class="toast" id="toast"></div>
    `
      this.toastElement = this.shadowRoot.getElementById('toast')
    }

    show(message, duration = 3000) {
      this.toastElement.innerHTML = message
      this.toastElement.classList.add('show')

      setTimeout(() => {
        this.toastElement.classList.remove('show')
      }, duration)
    }
  }

  customElements.define('toast-notification', ToastNotification)
</script>
